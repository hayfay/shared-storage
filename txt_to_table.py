import os
import glob

def parse (dir):
    count0 = 0
    count1 = 0 # Счётчики, служащие для того, чтобы отслеживать повторно встречающиеся слова.
    count2 = 0
    count3 = 0
    count4 = 0
    json = open(glob.glob(os.path.join(dir + '*' + 'gw.json.j2'))[0], 'r') # Конфигурационный файл с почти всеми необходимыми параметрами.
    output = open(dir + 'output.txt', 'w') # Файл, получаемый на выходе, с готовыми собранными данными из json и policy.

    #################################################################################################################

    word0 = '"endpoint"' # Искомые слова.
    word1 = '"method"'
    word2 = '"resource_type"'
    word3 = '"action"'
    word4 = '"git.omprussia.ru/auth/krakendaudit"' # Проверка на регистрацию событий. Наличие этой строки в проверяемом файле означает, что "регистрация событий" имеется.
    k = '' # Производим первичную запись искомой информации в одну строку. В дальнейшем эту строку разделим по эндпоинтам (каждый эндпоинт со следующей строки).
    mass_k = ['' , '' , '' , '' , '']
    for i in json:
        if word0 in i: # Поиск слова word1 в строке i
            mass_k[0] = i.replace('"endpoint"', 'метка') # Слово "метка" служит для дальнейшего переноса строки.
        if word1 in i and count1 == 0: # Поиск слова word1 (method) в строке i и проверка по счётчику, что такого слова для этого эндпоинта не было ранее.
            mass_k[1] = i.replace('"method"', '')
            count1 += 1
        if word2 in i and count2 == 0: # resource_type
            mass_k[2] = i.replace('"resource_type"', '')
            count2 += 1
        if word3 in i and count3 == 0: # action
            mass_k[3] = i.replace('"action"', '')
            count3 += 1
        if word4 in i and count4 == 0: # Проверка на регистрацию событий.
            mass_k[4] = 'Да'
            count4 += 1
        if i == '      {\n': # При встрече следующего эндпоинта (перед его началом встречается '      {' строкой выше(ровно 6 пробелов и открытая скобка)).
            if count1 == 0:
                mass_k[1] = 'Отсутствует,' # Пишем, что метода нет, если для эндпоинта отсутствует параметр "method".
            if count2 == 0:
                mass_k[2] = 'Отсутствует,'
            if count3 == 0:
                mass_k[3] = 'Отсутствует,'
            if count4 == 0:
                mass_k[4] = 'Нет'
            count1 = 0
            count2 = 0
            count3 = 0
            count4 = 0
            for j in mass_k:
                k += j
    if count1 != 1:
        mass_k[1] = 'Отсутствует,' # Пишем, что метода нет, если для эндпоинта отсутствует параметр "method".
    if count2 != 1:
        mass_k[2] = 'Отсутствует,'
    if count3 != 1:
        mass_k[3] = 'Отсутствует,'
    if count4 != 1:
        mass_k[4] = 'Нет'
    for j in mass_k:
        k += j

    k = k.replace('\n', '') # Стираем все переносы строк в разных комбинациях (r, n, rn).
    k = k.replace('\r', '')
    k = k.replace('\r\n', '')
    k = k.replace(' ', '') # Стираем все пробелы.
    k = k.replace('метка' + ':', '\n') # Делаем перенос строки, при встрече метки.
    k = k.replace(':', '')  # Стираем все двоеточия.
    k = k.replace('"', '')  # Стираем все двоеточия.

    count0 = 0
    mass1 = k.split('\n')
    k = ''
    for i in mass1: # Удаляем первую пустую строку в k (иногда в первой строке может быть мусор).
        if count0 > 0:
            k += 'метка' + i
        count0 += 1
    k = k.replace('метка', '\n') # Делаем так, чтобы каждый эндпоинт начинался с новой строки.
    k = k[1:] # Удаляем сивол переноса строки в самом начале.
    print('\n\n' + '#'*170 + '\nДля ' + dir + ' :\nk = \n', k)

    #################################################################################################################

    if os.path.exists(dir + 'policy.json.j2'): # Проверка на наличие файла policy.
        policy = open(glob.glob(os.path.join(dir + 'policy.json.j2'))[0], 'r') # Файл с доступными ролями.
        word6 = '"subject"'
        word7 = 'resourceType'
        word8 = 'action'
        count1 = 1
        count2 = 1
        s = ''
        for i in policy:
            m = i.replace('"', '')
            if word6 in i: # Поиск слова word1 в строке i
                if count1 != 1:
                    s += 'Отсутствует,' # Пишем "нет", если для subject отсутствует параметр "resourceType".
                if count2 != 1:
                    s += 'Отсутствует,' # Пишем "нет", если для subject отсутствует параметр "action".
                s += m.replace('subject', 'метка')
            if word7 in i and count1 != 1: # Поиск слова word7 в строке i и проверка по счётчику, что такого слова для этого subject не было ранее.
                s += m.replace('resourceType', '')
                count1 += 1
            if word8 in i and count2 != 1:
                m = m.replace(',' , '') # Чтобы в конце не стояла запятая
                s += m.replace('action', '')
                count2 += 1
            if word6 in i: # Обнуление счётчиков. Значит встретили следующий subject.
                count1 = 0
                count2 = 0
        s = s.replace('\n', '') # Стираем все переносы строк в разных комбинациях (r, n, rn).
        s = s.replace('\r', '')
        s = s.replace('\r\n', '')
        s = s.replace(' ', '') # Стираем все пробелы.
        s = s.replace('метка' + ':', '\n') # Делаем перенос строки, при встрече метки.
        s = s.replace(':', '')
        s = s[1:] # Удаляем сивол переноса строки в самом начале.
        policy.close()
        print('\ns =\n', s)

        #################################################################################################################

        mass1 = k.split('\n') # Преобразовываем строку "k" в список (одномерный массив).
        mass2 = s.split('\n') # Преобразовываем строку "s" в список (одномерный массив).
        r = ''
        for i in mass1:
                mass3 = i.split(',') # Преобразовываем строку "i" списка "mass1" в список (полуается двумерный массив, но только на один цикл i).
                r += 'метка' + i
                count1 = 0 # Счётчик, сколько найдено совпадений для строки i (для каждой строки в k).
                for j in mass2:
                    mass4 = j.split(',')
                    if (mass3[2] == mass4[1] and mass3[3] in mass4[2]) or (mass4[1] == '.*' and mass4[2] == '.*' and mass3[2] != 'Отсутствует' and mass3[3] != 'Отсутствует'):
                        count1 += 1
                        if count1 == 1: # Если встретили совпадение первый раз.
                            if mass4[0] == '': # Проверка, если встретили случай: "subject": ""
                                r += ',' + mass4[0].replace('' , 'Пусто')
                            else:
                                r += ',' + mass4[0]
                        if count1 > 1: # Если встретили совпадение уже не в первый раз.
                            if mass4[0] == '': # Проверка, если встретили случай: "subject": ""
                                r += '+' + mass4[0].replace('' , 'Пусто')
                            else:
                                r += '+' + mass4[0]
                if count1 == 0:
                    r += ',Отсутствует'

        r = r.replace('\n', '') # Стираем все переносы строк в разных комбинациях (r, n, rn).
        r = r.replace('\r', '')
        r = r.replace('\r\n', '')
        r = r.replace('метка', '\n') # Делаем перенос строки, при встрече метки.
    else: # Если файл policy отсутствует.
        r = ''
        mass1 = k.split('\n') # Преобразовываем строку "k" в список (одномерный массив).
        for i in mass1:
            r += 'метка' + i + ',Отсутствует' # Добавляем в каждую строку, что subject Отсутствует.
        r = r.replace('метка', '\n') # Делаем перенос строки, при встрече следующей метки.
    r = r[1:] # Удаляем сивол переноса строки в самом начале.
    output.write(r)
    json.close()
    output.close()

#################################################################################################################

folder = ''
for i in os.walk('resources'): # walk возвращает кортежи, поэтому запишем всё в строку по имени "folder".
    folder += str(i) + '\n'
folder = folder.replace('(' , '') # Раз это строка, то избавимся от лишних символов.
folder = folder.replace(')' , '')
folder = folder.replace("'" , '')
folder = folder.replace('\\' , '/') # Поменяем обратный слеш на обычный.
folder = folder.replace('//' , '/') # И поменяем везде двойной слеш на одинарный.

mass = folder.split('\n') # Разделим строку на список для обработки каждого элемента списка (массива).
for i in mass:
    if '-gw.json.j2' in i: # Если в элементе списка найдены такие символы, то:
        mass_dir = i.split(',') # Разбиваем строку на ещё один массив и...
        direction = mass_dir[0] + '/' # Вытаскиваем оттуда самый первый элемент (нулевой), где содержится путь к файлу.
        parse(direction) # Вызываем функцию обработки файлов.

'''
1) Для работы скрипта необходимо создать рядом с файлом скрипта папку resources и положить в неё необходимые файлы (папки appstore, auth, cdn, emm, pkgrepo со всем прилагающимся внутри).
2) Запустить скрипт и в случае успешного выполнения программы рядом с каждым файлом *-gw.json.j2 появится файл output.txt, внутри которого находится обработка каждого эндпоинта.
3) Навигация внутри output.txt далее. Каждая строка - это следующий эндпоинт, для которого:
    первый столбец - это эндпоинт;
    второй - метод;
    третий - объект доступа (resourсe type);
    четвёртый - тип доступа (ation);
    пятый - ведётся ли регистрация событий;
    шестрой - список ролей.
'''